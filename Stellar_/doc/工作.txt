0:15 2008-8-13
地形渲染基本框架实现，按照纹理排序渲染。

接下来是静态模型

17:34 2008-8-12
渲染时：
1、设置一张纹理
2、渲染可见DIST中所有用到这张纹理的索引
3、反复

所有DIST创建索引时根据纹理数量创建了对应的索引缓冲（参考TileDrawTable)。

注意：不是按DIST在一个DIST中渲染所有纹理，而是按纹理渲染！！！
设置纹理-渲染所有-再设置纹理-再渲染所有。


0:42 2008-8-12
地形纹理组织方式：
将所有需要渲染的顶点提交到动态缓冲
根据贴图不同，为每个DIST创建渲染索引缓冲。

方案2：
将所有需要渲染的DIST都提交后，创建索引缓冲时根据需要渲染的DIST，整合在一起渲染，比如，需要渲染9*9个DIST，顶点索引就根据纹理不同将统一创建这9*9个索引在一起。
先根据纹理，再设置索引，一次性渲染同一张纹理的所有格子。

17:31 2008-8-9
KOK地形模块渲染：
分两块实现：1、数据块。2、渲染块。
分别用Terrain和TerrainInstance做相应的功能。
Terrain负责数据加载，解析，保存数据和所有district。
TerrainInstance负责渲染，更新meshpool，填充顶点等。

设定：渲染主角所在范围3*3大小的DISTRICT，TerrainInstance中创建3*3个DistrictNodeInstance，主角移动时，实时更新这3*3个DistrictNodeInstance，而数据缓冲加载4*4个DISTRICT，但是，在主角移出范围时并不释放DISTRICT数据，而是一直保存着，直到切换地图，因为地图是限制的32*32个DISTRICT，所以不需要实时释放，这样当主角移回来的时候不需要再加载数据，可以提高效率。



15:13 2008-8-8
加载的DISTRICT可以不释放，反正最多32*32个DISTRICT，如果不释放，以后用的时候就不用再创建。

可能需要重新设计，需要考虑使用ModelInstance和ModelNodeInstance。

13:07 2008-8-7
1、加载地型块的方式
2、纹理渲染方式

原加载方式：
将所有地图数据一次性加载进来，如创建256*256个格子，把格子相关的阻挡、4层贴图、4个顶点、水面等级等等一次性创建，直接在内存中占用16M左右数据。

按dirstrict加载和处理数据，不需要cTerrainMeshGridNode这样庞大，把它的功能分解到每个dirstrict中。每个district保存9*9个node(即8*8个格子需要的顶点高度），这样每个dirstrict会浪费1*1数据，因为每个dirstrict都会有重复。

8*8

18:46 2008-8-6
纹理整合在一起渲染，只需要一个UV坐标（如果用SHADER，一个都不用，直接放到位置后面^^）
在进入DISTRICT前把用到的所有纹理都混合成一张纹理即可。

原万王渲染的缺陷：
贴图是按格子来的，也就是说一个格子最多可以放四张贴图，而渲染是以DISTRICT为单位，一个DISTRICT最多可以使16张贴图，这样就导致每次渲染贴
图数都不一样，目前是通过设置顶点索引的办法解决的（不太好）：根据纹理层次、贴图、格子组织顶点索引，也就是说将四层中所有贴图相同的索引在一起，这样一来，如果贴图没超过四张，就可以一次渲染完成，否则就要多做一次渲染。在一次渲染过程中，如果一个格子用到了多张贴图，会画多次。


0:02 2008-8-6
vb怎么组织？按district组织，一个district = 8*8*16*4
dynamic vb

15:35 2008-8-5
问题：顶点带宽太大，使用了五个纹理坐标来表示每层和阴影纹理的位置！
解决：
1、因为每张纹理中的块大小是固定的，所以使用shader，传入块编号，来使用纹理，这样四张纹理要传入4个编号，再加一个阴影，就是5个float
2、因为大部份地型上不需要做混合，只用一张纹理，只有处理边界的时候才需要混合，所以在进入场景的时候预渲染一张纹理，把所有用到的边界先渲上去，用的时候碰到使用混合的就从这里取纹理，这样就可以用一张纹理，一张阴影图搞定。

看样子只能选择第1种。

0:05 2008-8-5
已实现lpq支持

解析并渲染地型：
1、设置地型顶点
2、纹理
3、组织方式，目前看来如下：
总大小 256*256
被分成8*8个district
每个district有32*32个格子
每个格子大小为5，如果放大就是10

渲染以district为单位，地型VB是动态的（m_pTileVB)
所有的地型数据都在cTerrain中组织，其中包含32*32个cDistrict，每个district包含8*8个格子和cDistRender、cCliffRender等，用于具体的渲染。
创建一个district顶点的数量好像是256*32，不知道为什么？


22:34 2008-8-2
已实现用FMemStack，因为功能比FrameAllocator更强。
主要用于临时变量的处理。使用都是通过new来实现!!

理想的安排，根据具体情况会有所变动，前面一星期的内容必需安时尽快完成，后面的东西可以分部份给别人做（如应用层）

下一步安排：		天数
支持解析WE文件		1
解析地形并渲染		5
解析模型并渲染		3
解析人物动画并渲染	5
场景管理		3	8.25号

调整并优化		1	在场景中帧数保持在50以上

人物			2-3	骨骼绑定、动作混合
speedtree		2-3	需要添加个支持库，并优化
灯光、雾		1
天空			1
水			2-3	折射、反射、HeatHaze特效
粒子			2
特效			2	实现简单特效或者框架
声音			1
脚本			2	不确定，可能需要新的数据库支持
GUI			2	功能的东西需要做些调整，所以大部份时间花在怎么兼容功能上。
网络			1


应用层:
人物			1
NPC			1
寻路			1
...


0:26 2008-8-2
unreal的FMemStack功能与Torque的FrameAllocator相同，都是在一帧渲染过程中集中释放一些小内存块。
什么情况下使用这个？哪些变量使用它？每帧渲染的时候都需要new的变量？首先要搞清楚到低该怎么用!!!!

FMemStack和FrameAllocator的区别
1、前者在某个类中声明（也可在是全局的），退出类的时候释放
   后者声明为全局，退出的时候设置标志，并不真正清除


0:43 2008-7-28
今天出现两个引擎设计问题：
1、多线程资源加载和解析，目前引擎并不提供多线程解析，用的消息机制并不支持继承，所以需要再创建一个线程专门做解析，并且跟据不同类型数据重载解析函数。
2、加载数据的类(XXXloader)是调用不同类型数据类设置各种数据，因为变量是保护的，所以要设置很多函数，非常繁锁，解决办法：直接设置加载类(XXXloader)为友员类，然后加载的时候直接调用变量设置。
	这样一来就不需要像老方法那样，每个资源类都需要继承自AsyncLoad把加载和解析放在资源类里面处理。

2:36 2008-7-25
内存管理，unreal3上有个FMallocWindows分配内存以及FStackMask用于临时变量分配，与TORQUE里面的DataChunk和FramerAllocator相似，看看哪个效率高，拿来使用。
另外，还要再加一个Memory pool固定大小内存的管理。

unreal3里面的Array、map可以拿过来用，效率应该不错，当然要与stl比较一下。

11:39 2008-7-21
让CPU在空闲的时候加载周边CHUNK，要显示的CHUNK优先加载。


22:38 2008-7-15
昨天的设想不用，直接把整个ADT文件流保存在TerrainTile中，每个chunk初化的时候只保存相对流中数据位置的指针（初始化时读取位置和BOX然后保存CHUNK偏移指针，别的什么都不干!!），当地图块可见的时候读取相应的数据。释放tile的时候删除占用的空间。

这样读文件的时候好像是快了，但是用数据的时候还要解析，而且在主线程，还不如用昨天的方法，将解析完的数据存起来，用的时候直接拿出来就可以。

23:01 2008-7-14
在TerrainTile中保存一份Stream，这份Stream中保存着所有chunk使用到的数据（如alpha、shadow贴图的源数据），这些数据从线程中取得，并不直接在主线程中创建相应的纹理，等到可见的时候再创建。
所有地型纹理也是在可见的时候才加载！！

22:50 2008-6-22
工作流程：
M2->N2
简单的场景，不需要数据库
简单物理效果（BOX碰撞），模拟功击和受到功击
粒子效果
拿武器

1:52 2008-6-19
效率！简单！
目标：实现多人在线对战休闲游戏。操作方式、视角与魔兽争霸相同！即45度固定视角。
疑惑1：采用WOW的M2模型格式，重新在N3里面实现一套支持M2的应用层设计，或者把M2格式转成N2格式。

采用前一种方式的好处：
根据原来的分析，M2格式设计上比N2要好，存储空间少，在内存中占用也会少些。

缺点：
重新设计一套应用层，与目前的一套结合。
实现骨骼动画、混合、绑定点等。

采用后一种方式的好处：
与应用层完美结合，只要把M2格式转过来后，可以继续实现粒子系统等。
基本功能已全部实现。

从开发效率和追求简单来说，无疑会选择后者，前者要做很多事，当然也可以学到很多东西，不过以目标为前提的情况下，
还是选择后者吧！！！


1:42 2008-6-13
继承BaseGameFeatureUnit，重载NewGame函数，建立自己的场景，目前不需要数据库。

1、简单的加载一张ground模型做为场景即可。
2、显示M2模型，并能做简单的动画
3、键盘操作，做动作，在场景中移动
4、实现动画多轨混合（M2里面应该可以实现双轨）
5、粒子效果绑定
6、碰撞
7、简单打斗物理效果。

第7点开始需要在场景中放两个对象（可以是BOX）。

希望可以在7月份之间完成4步！


1:40 2008-6-12
整个地形设计有问题，在entity中不能创建其它entity，就算创建了，删除的时候也不能在entity中删除，否则会出问题。
重新设计TerrainEntity，不用继承自GraphicsEntity，直接放到WorldManager管理即可！暂时不解决，接下来的项目可能不用地形。

接下来开始做Fighter 3D项目！

1:26 2008-6-11
这边的工作先放一下，目前不适合做大型RPG游戏开发，先做个休闲格斗游戏，从今天开始，做Fighter 3D游戏。

工作安排如下：
修改目前NEBULA中出现的问题（如释放出错等）
熟悉并搭建NEBULA3应用层，开始做游戏。
加载一张ground模型做为地形，休闲游戏场景不会太大，所以只用一个模块搞定。
实现角色动画，格斗效果。
实现粒子和魔法效果。


0:03 2008-6-10
昨天将ResourceManager、SimplerResourceMapper、ShareResourceManager三块用stl::hashmap代替了原来的Directory。
加载模块已经达到常量级，已基本实现不卡。

接下来的工作：
1、地形正常浏览，目前地形加载模块设计不理想，加载模块可以尝试用原来的方法（而不是使用发消息去加载，待定！）。
2、四叉树，场景更新和渲染目前只有十几帧。
3、天空
4、水
5、模型：静态、动态
6、八叉树
7、WMO
8、粒子
9、特效：广告牌、HDR、BLOOM、等等
10、地形编辑器
11、模型编辑器
...

2:57 2008-5-30
把ResourceManager和SimaplerResourceMapper整合在一起了，用同一个资源HashTable，这样创建和查找的时候就只有一份数据，避免浪费。
速度有所提升，今天没怎么测试到低ResourceManager哪块卡。

hasttable类中还有个BUG，没时间了，下次解决。
目标是DEBUG版只加载地形要达到100帧以上，加载还要流畅！！！

2:20 2008-5-29
资源管理中替换成HashTable，效率有所提升，不过数量多的时候还是非常卡。
尝试用std::map

测试具体在哪个位置卡。(可以肯定是在CreateManagedResource里面某处)

2:24 2008-5-28
尝试将资源管理中用的Directory改成HashTable.以提高效率。
发现用Atom<String>做为ResourceId非常慢，因为每次资源增加的时候都需要排序，对字符串进行strcmp，这个函数非常慢，特别是调用次数过多的时候。
2:23 2008-5-26
两处可能引起卡的问题：
1、在Stage中更新所有entity，一旦enttiy很多的情况下，每个entity都要创建instance，会很慢，
	解决办法：把动态和静态entity分开，更新的时候只更新动态的。在加载的时候创建instance，必免更新的时候在一起创建，从而占用大量时间。
2、在资源管理模块中所有的资源都在一起更新，比如在ShaderResource中的resource是Directory类，每次增加一个资源都会排个序，非常慢。
	未解决，有待测试。


2:27 2008-5-22
新的加载方式导致WDT未加载成功
CHUNK加载的时候非常快，卡住可能是主线程哪里加载的时候有问题。

1:59 2008-5-19
随着加载数量的增加，明显的越来越慢，加载完成后虽然帧数很低，但相对稳定，所以第1点应该是问题的关键：
1、四叉树查找的时候会不会慢，将对象添加到合适的位置费多少时间？
2、查看渲染了多少对象，随着渲染对象的增加，也会降低速度。
3、视锥裁剪改成furstum

另外，将MPQ加载方式改成用stromLib！
实现连续加载地形。

2:42 2008-5-15
cell分布有问题，四叉树中的实例不是平均分布的？

1:49 2008-5-12
多线程加载基本框架已实现，还存在些问题，如怎么样设置managed里面的变量！！
多线程加载方式：辅助线程加载文件，需要数据的地方发读文件消息从辅助线程读，而不是一定性全加载了。

正常运行并显示地形
测试速度
添加FPS

=========================================================================================
lod
camera
fps

adtread的时候new新的内存，这块需要改掉。目前主线程还是很卡。terrainchunkentity放到WorldManager中实现。




M2
换装
max插件


需要处理的东西：

地形
  模型变换（位置、旋转、缩放）
  所有资源的BOUNDBOX（变换后BOX也要跟着变换）
  地图上有些小点空隙

  静态阴影(lightmap)
  加载多块地形（根据摄像机移动来加载需要的地块，释放不需要的地块）
  地形四叉树管理
    quadtree

  灯光
  地形高光

  Lod

wmo 
  protal bsp

m2 
  动画 粒子系统 mipmap

其它
  water
  sky
  fog
  load system  
    cpu->memory  memory->gpu
  index buffer 使用TRIANGLE STRIP，最后一个三角形使用退化（degenerate triangle）处理。



计划: bsp portal loadsystem animation partical water sky fog 优化  WorldEditor ModelEditor ParticalEditor
时间: 2008-2-22                                          2008-3-30                                      2008-5-30
////////////////////////////////////////////////////////////////////////////////////////////////////

floating-point precision errors 浮点精度问题
http://www.cs.unc.edu/~geom/theses/gottschalk/main.pdf     aabb


0.使用天空球包围整个世界,使用雾限制可控远景.
1.地形裁减: 
  1.使用四叉树算法对MapArea->AreaChunk逐层进行相对镜头的可见性裁减.
  2.在1过程中,对镜头内的地形进行水平线扫描剔除.
  2.然后镜头裁减完的区域必然是连续区域,对此连续区域作ROAM算法下的LOD处理,近细远粗.
2.模型裁减: 
  1.基于上述地形四叉树裁减下作基本的每一个模型的裁减,实践测试结果表明收益大于测试成本.
  2.距离裁减:以镜头为中心画圆,处于远景雾外的模型不作渲染,模型进雾后会逐步显示,这样不会有poping缺陷.
  3.不采用模型LOD,数据制作过于复杂,控制复杂,加大内存需求,也有poping缺陷,优点不明显.
  4.在地形水平线裁减中剔除物体.
3.进入BSP室内场景后的裁减.
