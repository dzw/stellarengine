21:00 2008-12-9
***优化点：stage不需要用两个entities保存数据，很浪费！

18:03 2008-12-5
如果没有找到资源，就用替代资源，解决因资源没有找到引起错误的问题。

17:37 2008-12-5
地形LOD注意：
切换地图的时候，LOD索引缓冲内容可以不需要变化，除非要加载的地形大小与目前的不同。
所有缓冲只需要创建一次即可。

20:59 2008-11-25
用havok做碰撞，好像可以提高速度。包括摄像机碰撞和魔法碰撞。

15:55 2008-11-25
天空上加雾：将雾的距离设置的比天空近，然后画天空，再将雾设置回来。

***改进：武器上加运动模糊，武器的效果是不是会更好？
参考http://ati.amd.com/developer/ShaderX2_MotionBlurUsingGeometryAndShadingDistortion.pdf

10:47 2008-11-11
***优化点：entity资源分类管理，按生物资源库、装备模型资源库、特效资源库等分类管理。

22:31 2008-11-10
***优化点：动态物件的场景管理，如人、魔法、NPC、怪等。显然不能用四叉树！

目前对应用层的作法：
首先使用WE中原来的BEING，先使用起来，以后再拆分。

17:29 2008-10-29
UI系统纹理相关：
征途中的UI纹理不需要按2的倍数进行处理，而是按实际的大小保存，使用的时候先创建一个纹理，然后把纹理加载到内存。否则按2的倍数会有很多空间被浪费掉。

注意：PHOTOSHOP中保存TGA有个压缩选项，在高级的版本中压缩完后可以保留ALPHA通道，低版本的没有，所以存成TGA比DDS要省3/4的空间！！！

11:38 2008-10-28
***优化点：使用NVPerfHUD工具对性能效率进行全面测试，可以参考GPU Programming Guide Chinese（在D:\BOOK中）一书进行测试。

23:47 2008-10-27
排序这块要设计一下，注意两点：
1、碰撞检测需要对像按前到后的顺序排，这和不透明物体画的顺序一样。
2、透明物体需要从后向前排，这可能需要重新排对象，会比较麻烦，比较好的解决办法是把透明实体拿出来排一下再画。

15:28 2008-10-24
thing加载的时候是先加载thingnode，然后判断这个node是不是特效，如果是再创建particle,这里如果事先知道这个node是特效的话直接创建particle就可以了！！！

17:22 2008-10-20
***优化点：目前地型阴影直接用A8R8G8B8做的，这会很浪费。必需优化！WE里面是把这些值存放在空照图中，不过这样也很浪费，因为每个DIST都不相同，渲染的时候可能需要重新排序。

10:40 2008-10-16
***优化点：许多模型法线设置不正确，效果会打折扣，可以调整光照来查看。

16:07 2008-10-11
特效动画不正确有可能是因为纹理的AddressU,AddressV设置不正确引起的。

0:32 2008-10-9
FPS时间不对，取值用xtimeGetTime??这也可能是导致动画速度不正确的原因之一。

22:44 2008-10-8
UI：直接搬原来的，以加快开发速度，所以UI也做为应用层来做，而不是低层
应用层：
    功能相关：罢滩、跳舞等
    游戏相关：NPC、Player、怪物、坐骑、PK、放魔法等

底层：
可行走地物
灯光
雾:雾、可见距离裁剪，增加可见Zfar值,产生远处有山的感觉，雾后物体只渲染几何
魔法特效（modeleffect)		10.8
speedtree加强：载剪、LOD
字体处理
特效加强：剩余的几个特效
天空加强：会动的云
水加强：反射、折射
设备丢失恢复
声音

***优化点：骨骼动画更新优化(_CHECK_NOUSE_ANIMATION)

14:30 2008-10-8
动态实例的可见管理:怪物、NPC、人物 的是可以动态改变位置的，目前对这种动态的entity(CameraEntity)是每次更新都会重新找cell，效率不高！
需要设置可见距离，这样看上去远处才有山的感觉

需要设计一些公用的函数，如三角形碰撞检测等。

0:12 2008-10-8
***优化点：加上雾的时候在CELL中也要加入距离判断，如果超过距离的直接不可见！！！这可以提高很多效率!!!

20:49 2008-10-7
玩了下校内网上的《狗狗》，一个感觉，游戏只要做的有意思，不怕没人玩。。。只要有人喜欢玩这游戏，就可以想各种办法招更多的人！！！

11:36 2008-10-7
地形boundingbox的高度要随地物一起变化，否则不能正确放置地物到指定的cell中，最好的办法是在编辑器导出地形的时候计算出地形每个District的boundingBox!!!

22:37 2008-10-6
需要处理：
1、人物转方向出问题
2、动画时间不正确
3、地形裁剪有问题
4、天空只是简单的一个，还需要加入云
5、水需要加折射、反射

17:36 2008-10-6
目前KOK里面水写的相当死，因为只考虑场景的水，并没有室内或者物体上的水效果（直接用纹理实现），所以写的时候就只是一个目标，不灵活。

14:48 2008-9-28
关于N3设计问题：
N3设计的时候就一个model，可以有很多不同的entity，但是node不需要太多，通过组合产生很多不同的效果，如天空也可以直接用ShapeNode表示。
现在的设计是每个不同的对像都会有新的node，因为NODE中不仅仅只保存MESH或MATERIAL，还有很多与功能有关的数据。或许可以把这些功能的数据都放到ENTITY或INSTANCE中，这可能吗？？？如果可以，这将大大减少代码量，提高重用率。


23:17 2008-9-27
***优化点：WE中就算看不到水也需要渲染水，所以需要增加个水体裁剪。

20:45 2008-9-27
策划：像浙江卫视台的《我爱记歌词》一样，做个比赛，经过N次比赛，冠军会有大的奖利。

23:51 2008-9-25
***优化点：相同的粒子是否可以一次画出来，反正都是trianglelist!!查看喷泉每个粒子都画一次(虽然只提交一次VB)，很浪费！！！
	   粒子必需优化！！！！！

20:18 2008-9-24
游戏制作的一些想法：
KOK现在的设计就是从魔兽争霸中来的，而魔兽争霸本身设计就不是做大世界或真实世界，而是做一个类似于想象的空间，所以地形比较小，人物也按一定比例在里面行动，感觉比较厚实，可以看到很多的物件和怪，任何设计都是基于此做的（有些像在做玩具），地形、怪、人都是这样，而魔兽世界的设计是基于世界的，在世界里面不太可能像前者那样可以看世界的很多东西。这就是玩具地图和真实地图的差别。

所以做设计首先要清楚哪些是有利的，怎么利用起来，才能做出最好的东西，而不是看人家好就做的和别人一样，这样只会越做越差！！！


23:10 2008-9-22
***优化点：effect可以定义一些宏，使用的时候动态设置是否打开这些宏，从而产生不同的需求。参考speedtree.fx的宏定义及使用。

14:08 2008-9-22
***优化点：模型渲染排序优化：
Model-node-batch
按模型-子模型-批次排序。
即：画子模型的时候再根据批次（也就是材质）再排序，因为现在已经按子模型排序了，只要在画子模型(Node)实例的时候再按批次排即可。
这个方法只是对相同模型的多个实例排序，并不是对不同模型做排序。
伪代码：
for (int modelIndex = 0; modelIndex < model.Size(); modelIndex++)
{
  const Array<Ptr<ModelNode>>& nodes = model[modelIndex]->GetModelNodes();
  for (int nodeIndex = 0; nodeIndex < nodes.Size(); nodeIndex++)
  {
    nodes[nodeIndex]->SetStreamSource(); // 设置VB,IB
    int batchNum = nodes[nodeIndex]->GetBatchNum();

    const Array<Ptr<ModeNodeInstance>>& nodeInsts = nodes[nodeIndex]->GetNodeInstances();
    for( int b = 0; b < batchNum; b++)
    {
      for( int instIndex = 0; instIndex < nodeInsts.Size(); instIndex++)
      {
        render(b);	// 画某个批次
      }
    }
  }
}

18:41 2008-9-20
shader状态管理需要重新整理，目前这套存在效率问题，如把状态值存到attr，每次渲染前要从这里取，速度很慢。

18:24 2008-9-20
目前地物和粒子的渲染时把纹理动画都放在一块，也就是说不管有没有纹理动画，都需要处理，这里需要优化一下。

15:16 2008-9-20
ssao效果不错！
ssao是Crysis用到的算法，“Screen-Space Ambient Occlusion” (屏幕空间环境光遮蔽)。
SSAO通过采样象素周围的信息，并进行简单的深度值对比来计算物体身上环境光照无
法到达的范围，从而可以近似地表现出物体身上在环境光照下产生的轮廓阴影。可以利
用“逐象素场景深度计算”技术计算得出的深度值直接参与运算。

现在的效果确实错误还比较大，应该先进行简单的空间划分（或类似处理）然后计算。
不过个人认为这种方法只是近似地模拟，效果并不正确，但确实能增强场景的层次感，
让画面更细腻，让场景细节更加明显。


16:45 2008-9-19
目前地物包含骨骼动画，有些用来设置位置，如喷泉那个流水就是通过动画设置才能到正确的位置。

15:47 2008-9-19
代码中有很多地方都需要*4800，这是因为MAX导出的时候1秒是4800，所以在计算动画的地方都需要elapsedtime*4800才是正确的时间。

13:51 2008-9-19
***优化点：.act文件放到多线程加载

10:21 2008-9-19
***优化点：模型需要重新整理：（动态和静态模型）
          1、清除无用的子模型
          2、清除不需要的骨骼	如hal039 hal038

***优化点：粒子系统按 mesh-纹理的方式排序，目前只按mesh排序，因为mesh是共用的。

23:50 2008-9-18
地物骨骼动画目前放在model中，所以所有相同的模型动画都是一致的，如果需要每个动画都不一样，需要把骨骼动画放到ModelInstance或entity中。

14:38 2008-9-18
渲染状态的设置可以放到NODE里面做，因为所有NODE的实例都是相同的状态，不需要每个都设置。

11:35 2008-9-18
粒子框架：
ParticleNode
  MaterialNode

ParticleNode中引用KokShapeNode，因为粒子分两种，一种是创造的粒子，一种是模型做为粒子，而后者需要加载模型，所以从KokShapeNode获得数据.
不管是哪一种，KokShapeNode都不会创建NodeInstance，而是创建ParticleNodeInstance去处理。
所以当加载完KokShapeNode的时候要判断是否是特效节点，如果是就创建一个ParticleNode去引用这个节点。(参考Thing::SetupFromStream)

10:29 2008-9-18
所有子模型特效GetEffectType()>0 的都不会创建子模型实例，而是创建一个粒子实例

粒子渲染用一个新的model处理，这样可以解决9-18号的问题。

10:16 2008-9-18
在dx9sampler.xml里面多加了两个batch,分别是particlesolid,particlealpha，做粒子不透明和透明渲染，虽然在单独的两个批次处理，但是还是没有按纹理排序。

23:12 2008-9-17
粒子系统渲染方式：
创建另一个批次专门用来渲染粒子，因为所有粒子设计成共用一个VB,IB，为提高效率，把所有模型的粒子节点都统一放在一个批次处理。

14:49 2008-9-17
N3原来有些东西不需要的可以去掉，如SM3.0阴影

10:47 2008-9-16
现在是按模型排序渲染，可以改成按NODE排序，先SHADER再距离。

13:05 2008-9-14
粒子系统渲染方式：
创建一个动态顶点缓冲，所有粒子共用一个缓冲，每次画前把需要的顶点填进去，数量满了就画，而不是为每个发射器创建一个顶点缓冲。

11:44 2008-9-12
粒子系统设计：
Particle		代表一个粒子数据	类似cPartilce
ParticleEmitter		粒子发射器		管理粒子，类似cParticleEffectBase
ParticleServer		发射器管理		类似c3dsMaxParticleManager
ParticleNode		存放粒子数据		保存c3dsMaxEmitDataBase读进来的数据
ParticleNodeInstance	渲染粒子		调用ParticleEmitter渲染


11:23 2008-9-12
***优化点：可以增加对多流的支持

10:37 2008-9-12
以后可以增加支持固定管线，通过设置frame.xml，根据情况使用哪种effect.

16:19 2008-9-11
***优化点：所有地物都是打开alphaTest的，非常浪费！

10:35 2008-9-10
类型为TYPE_REPEAT的thing子模型在创建NODE时不需要为每个子模型都创建MESH，因为使用的时候就用到一个，类似的情况可能也出现在其它几种类型中。

21:21 2008-9-9
thing子模型类型：
	TYPE_NORMAL				一般的模型
	TYPE_HD,            // "m_hd"		子模型是地板，人可以行走上去
	TYPE_LIGHT,         // "m_light"
	TYPE_REPEAT,        // "m_repeat"	模型中包含多个子模型，其中只有一个需要显示。
	TYPE_SELECT,        // "m_select"	选择时做碰撞用的，可能是个简化的模型，先用boundingbox判断，再做面判断。
	TYPE_WATER,         // "m_water"
	TYPE_EFF,           // "e_ff"		也是f的格，特效用
	TYPE_EFLAME,        // "e_flame"	f的格，做路艄馄用( billboard )

TYPE_NORMAL,TYPE_HD,TYPE_REPEAT是参与渲染的子模型，其它模型不渲染，所以不需要创建nodeInstance，直接从node中取得信息处理。

23:42 2008-9-8
材质系统设计：

1、创建NODE时，取得相应渲染状态的值，为每种渲染状态创建一个shadervarible
2、使用时直接循环应用创建的所有shadervarible
3、特殊的渲染类型（如纹理，因为每个实例都可能不一样）放到NodeInstance中处理。

是否需要设置shaderParam？像N2的nShaderState::Param


21:26 2008-9-8
地物罢放位置已正确。

1、地物可见性判断存在问题，经常找到几百个物件，是否需要加个距离判断？（在CELL里面）
2、加载方式有问题，没有按优先级先加载附近的物件。


0:40 2008-9-7
material是被共用的？所以里面的纹理需要其它方法控制，material需要重新设计。

18:03 2008-9-6
thingentity在没有另载前只能根据距离判断是否需要加载，本来想如果可见就让加载的，但是判断可见性需要boundingbox，而现在WE里面不支持这个!!!

20:35 2008-9-5
***优化点：release版还n_assert还是有做用，可以屏掉这些判断，效率可以提高很多，这些可以放到releasetest版中。
	   所有其它工程release都设置成以速度最优方式/o2

11:32 2008-9-4
模型的贴图有两种情况：
1、贴图不变，加载的时候就可以创建完成，不管有多少实例，贴图都是一样
2、贴图有变化，相同的模型有很多不同的贴图，像装备、武器都是这样，所以需要把贴图设置放到实例中处理。attach到实例的时候处理加载贴图过程


17:26 2008-9-3
刀光：武器子模型中名字带m_shadow的就是用来做刀光的
m_shadow有控制c，移游淦麽算出新的m_shadow控制c位置，再⑿屡f控制cM成polygon
自己的刀光有作炔澹e人的刀光]作炔澹可以看出差e

武器子模型中名字带b_00的就是一立方w，粒子特效只在@立方w犬a生


16:10 2008-9-2
***优化点：为装备、身体部件这些可以共用的模型创建一个资源列表，游戏运行过程中加载了就不释放，隔一段时间判断，如果很久没人使用，才释放，加载资源时，优化从这些列表查找，提高速度。（不需要在BeingEntity中做这方面的事）

14:39 2008-9-2
应用层相应关系：
BeingEntity
    NPC		monster		无换装,NPC没有换装等功能，而其它大部份功能在actor中也用到
       actor	mount		需换装，设置功击状态，骑马，背包等等。


得找个现有的游戏参考下应用层设计。


应用层：
设置动画、武器、坐骑、换装



11:04 2008-9-2
***优化点：尽量把重用的资源放到model层做，如骨骼动画、骨骼层级应该都可以放到Being中，这样其它人物就不用创建，直接使用同一套!!!

23:47 2008-9-1
装备设计：
Equip : public Model			模型其实和地物是一样的！！
EquipInstance : public ModelInstance	装备实例，可能包含很多特效，本来想用EquipEntity表示，但是装备是放在BeingEntity中的，所以还是					用ModelInstance表示了。

16:10 2008-9-1
***优化点：渲染假反光时，状态切换太频繁！

17:12 2008-8-30
***优化点：骨骼更新效率非常低！！！BeingEntity::UpdateSkeleton()

23:34 2008-8-29
转眼一个月过去了，这个月总结：
0、引擎优化
1、地形		基本实现，未做阴影、游戏相关内容				半个月左右
2、地物模型	基本实现，未做材质、摇动、纹理动画				一星期
3、骨骼动画	基本实现，关系太乱，效率低，需要优化，未做反射贴图、装备	一星期（未完）

开始的时候费了些时间，对WE的代码整体认识需要点时间，再加上代码太乱！所以地形用的时间长了点，设计上也重写了几次，这里也浪费了几天时间。地物相对简单，骨骼动画目前只完成初步，估计没有半个月难有好的效果。总的来说，万事开头难，相信以后会越写越顺。加油！^^

9月份工作安排：
骨骼动画、换装、反射贴图、材质、地物摇动、纹理动画、地形阴影，整体组织。  1-2周
实现 speedtree、天空、水、雾、特效，放个人进去跑			  1-2周
剩下时间 场景管理、优化

9月份目标：实现基本效果，并放一个人在场景中跑。

10-11月：
实现整套效果，开始实现应用层。


17:56 2008-8-29
反射贴图：
有一反光D(似一A球的D，中g最亮)，
然後利用D3DTSS_TCI_CAMERASPACENORMAL@TextureStage，
把D到z影C空g的Normal作NDS，
所以Normal正z影Cr，便得到反光D中g最亮的地方，
a生反光效果
另外有一控制哪要有反光的反光控制D

例如身w盔甲，有一外形和原本盔甲一模一拥姆垂饪刂瀑ND，因槭怯迷本的NDS，但是反光控制ND上面的色是用砜刂品垂獾某潭

[蛑杏玫纳眢w盔甲ND，s小^的
1_2是反光控制ND
可以看到身w部份是黑的，不^金俨糠菥陀蓄色
有色的地方才有反光


16:17 2008-8-29
***优化点：等所有的做的差不多的时候，全力优化，可以参考joint Task Force一些做法。
***优化点：改变文件格式，目前的格式只能一块一块读，不支持偏移访问（如：importAnimationKeysFromMemory）读数据效率太低！

0:41 2008-8-29
已实现骨骼创建，渲染模型
明天实现更新骨格层级，取变换矩阵更新。

15:23 2008-8-28
***优化点：读文件时需要搜文件所在的包，因为没有区分具体在哪个包，所以每次打开文件都要查找所有包，这样效率可能会比较低！
	  可以试着把所有文件按目录打在一个包里面？或者为每个包指定一个目录？或者？？？

11:16 2008-8-28
模型模块重新设计：
ThingEntity		图像实例
  Thing			加载资源、管理所有子模型等
    ThingNode		静态或摇动物件设置，可能需要改变顶点格式
      kokShapeNode	统一解析数据的地方，产生基本的顶点格式，根据具体使用情况，需要对这些顶点做改变（如摇动、骨骼动画等）

BeingEntity
  Being
    BeingNode		骨格动画需要重新计算生成shader版的顶点格式，产生矩阵模板,nodeInstance需在从骨骼框架中取得变换矩阵！
      kokShapNode

CharJointPalette	子模型骨骼矩阵模板


WE的文件格式设计看似的点继承，实际上没任何关系，所以重新设计，直接把两者分开，清楚的看到这之间的关系。

0:34 2008-8-28
人物动画：
目前we提供的模型顶点格式中只包含pos,nor,tex，而人物动画shader实现需要weights[4]和indices[4]（权重和变换矩阵）
所以，需要将顶点格式转成后者，就是将cSkinWeights中保存的weight,indices转到每个顶点上。

cSkinWeights中保存的骨骼的偏移矩阵，这个矩阵必需和骨骼变换矩阵相乘，所以需要保存在什么地方？
M2里面没有这个矩阵，而是直接把骨骼移到原点，然后变换，完了再移回来。

VertexFVF v[顶点数总];
for(int i = 0; i < cSkinWeights::meshVertices; i++)
{
  int n = cSkinWeights::VerticesIndex[i];	// 索引
  int k = index[n];				// 从索引取得顶点
  for(int j = 0; j < 4; j++)
  {
    if(v[k].weights[j] == 0)
    {
      v[k].weights[j] = cSkinWeights::VerticesWeight[i];	// 这里要判断加入的权重不要复盖原来的！！
      v[k].indices[j] = GetPattlenIndex(cSkinWeights::skeletonName);	// 设置变换矩阵索引,注意索引顺序.  参考：@1
    }
  }
}
骨骼矩阵变换完后再乘上相应骨骼（根据名字取得）的cSkinWeights中的偏移矩阵，就是世界变换。

考虑到整个模型骨骼数太多，所以按子模型渲染方式组织骨骼变换矩阵，也就是说传入shader的骨骼顺序是根据子模型设置的。

从变换到shader的步骤：
1、根据当前时间变换每个骨骼(frame更新)
2、循环所有骨骼，用相应的cSkinWeights乘上偏移矩阵
3、传入shader,shader中开始对顶点计算

@1:
  怎么组织顶点的四个变换矩阵索引？
  直接根据子模型的cSkinWeights顺序保存，用的时候需要动态产生变换矩阵，根据cSkinWeights中的名字从整个骨架类SkeletonSerializer中取得相应矩阵，再乘上自身偏移矩阵，再传入shader.

15:42 2008-8-27
人物模型注意事项：
1、人物模型需要支持换装，所以纹理需要单独设置，而且每个部件子模型的纹理编号都是相同的。


0:46 2008-8-27
把角色模型框架基本搞定，不过还没显示出来。
写个测试平台，模型浏览程序。


17:47 2008-8-26
***优化点：没有按文件类型分开存放，如纹理和模型放在一起，这样找文件的时候需要多保存一个字符串来确定位置。

15:59 2008-8-25
采用NEBULA2的方法设置材质，基本机制不变。
StateNode是一个shader，是材质的基础
StateNodeInstance相当于材质，不同的状态和材质信息都放这里更新，每个实例可能都不相同。

***优化点：是否需要在设置effect变量的时候加个判断，如果要设置的值和effect中相同就不设置，因为设置一次都需要更新到GPU上。

19:31 2008-8-25
atf是骨架n
stb是幼骶c音效n名φ毡
xtb是幼骶c幼n名φ毡
atm人物的模型n
sto 地物阻觞cY料
etb 幼魇录表
lio是c光源n，存c光源的蒂Y料
lig是鼍肮庾Vn，存各rg的h境光和太光蒂Y料

音效用wav
背景音mp3

16:50 2008-8-25
材质模块设计：查看nebula3.vsd

15:59 2008-8-25
采用NEBULA2的方法设置材质，基本机制不变。
StateNode是一个shader，是材质的基础
StateNodeInstance相当于材质，不同的状态和材质信息都放这里更新，每个实例可能都不相同。

***优化点：是否需要在设置effect变量的时候加个判断，如果要设置的值和effect中相同就不设置，因为设置一次都需要更新到GPU上。


18:27 2008-8-23
需要创建一种material机制。

0:18 2008-8-23
接下来要做的事：
thing: 
	静态模型
	动画		animation skeletonhierarchy 动态纹理
	摇动的花和树处理	不同的顶点格式
	阻档点
	特效
	灯光	有个光的连接点。
	
being:

三个阶段：
	实现：直接用万王现有的东西加入到引擎，以速度优先的方式实现整个效果，不包括功能模块。	一到一个半月
	优化：将上阶段实现的东西改成引擎方式表达，设计框架。增加新东西。			一到二个半月，到这里不能超过四个月。
	稳定：做功能和稳定程序。								
1月前

21:52 2008-8-22
***优化点：为每次资源建立管理列表（cache），要细分创建，这样搜索的时候速度更快。如shader可以为各种EmissiveTileShader创建一个队列！(参考unreal)

16:21 2008-8-22
***优化点：根据每个子模型的batch，是不是可以判断可见性再画？看不见的不画。可以试试
***优化点：根据batch，再根据shader排序画！

23:27 2008-8-21
***优化点：去掉N3里面不需要的东西，ManagedResource、ResourceReader、N2格式等。
***优化点：优化String、Array、Map、HashTable等。
***优化点：优化vector、float4等。
***优化点：优化camera裁剪，用frustom裁。

15:28 2008-8-21
***优化点：MDLVTX中blend做摇动动作的混合，只有小草才用到，不需要把所有的地物都设成这种格式！

23:45 2008-8-20
***优化点：String类需要做优化，默认的20个字节很浪费！最好从堆上面获取空间，或者专为字符串类申请一大块空间，给所有字符串用。
           或者可以直接把默认的20个字节去掉，每次都从堆分配，这样不使用的时候就不会浪费空间，用的时候申请也很快!!!找时间改过来!

16:49 2008-8-20
.x动画相关数据：
AnimationSet	动画，一系列动画
	Animation 动画相关的骨骼
		KeyFrame	帧
Frame	骨骼层级，很多级
mesh	网格
skinweights 骨格权重，组织骨骼和网格的关系。

kok动画：
cAnimationKeys:保存了某个骨骼的所有动画帧。（而.X中keyframe就保存某个骨骼某个动画的帧，并不是所有动画都放在一起）
cAnimationActionInfo:保存了所有动画信息，如某个动画使用哪些帧。（而.x中分开保存帧和动画，用AnimationSet表示一个动画，并不是合在一起）
cSkeletonHierarchy:骨骼层级。
	cAnimation:当前骨骼所有帧信息。保存与当前骨骼相关的cAnimationKeys。
cAnimationActionInfoGroup:


人物的骨架和幼魇枪灿玫模例如f^p子的骨^，如果是用光^模型的，可能就不用到此p子的骨^，如果有定x_CHECK_NOUSE_ANIMATION的，就不算p子骨^的赢


17:12 2008-8-19
地形基本解析完成，开始解析模型，模型有两点比较麻烦：材质和批次渲染。N3没有材质概念，暂时直接用SHADER实现，批次放到NODEINSTANCE中实现。
WE中的灯光放在DISTRICT中，所以不需要像N3那样按可见性设置灯光，当然框架可以使用原来的。。

20:04 2008-8-15
***优化点：从PIX记录发现，很多DIP都只画两个面，DIP次数太多，可以考虑用SHADER把相同层，相同纹理的顶点索引在一起，有个问题就是每次画之前都要重新组织索引，不知道效率怎么样，有空再做。

23:07 2008-8-14
雾距离130
物体裁剪距离要比地表裁剪距近，可以和雾的距离差不多。
雾设置的近点，地形就基本不用lod

动态顶点缓冲有问题！！！


按 shader-texture-格子距离 排序试试   测试结果：这种方式效果最好!!!


11:09 2008-8-13
加载全部NODE和NODEINSTANCE。渲染在NODEINSTANCE
四叉树载剪，获得载剪后的列表。

alpha层shader
渲染排序:
目前是
层-纹理-格子
改成：
纹理-层-格子方式渲染试试。


***优化点：可以将所有模型按节点分，这样大的模型看不到的部份就不渲染。
***优化点：把model的render部份分到每个modelnode和modelnodeinstance中。

0:15 2008-8-13
地形渲染基本框架实现，按照纹理排序渲染。

接下来是静态模型

17:34 2008-8-12
渲染时：
1、设置一张纹理
2、渲染可见DIST中所有用到这张纹理的索引
3、反复

所有DIST创建索引时根据纹理数量创建了对应的索引缓冲（参考TileDrawTable)。

注意：不是按DIST在一个DIST中渲染所有纹理，而是按纹理渲染！！！
设置纹理-渲染所有-再设置纹理-再渲染所有。


0:42 2008-8-12
地形纹理组织方式：
将所有需要渲染的顶点提交到动态缓冲
根据贴图不同，为每个DIST创建渲染索引缓冲。

方案2：
将所有需要渲染的DIST都提交后，创建索引缓冲时根据需要渲染的DIST，整合在一起渲染，比如，需要渲染9*9个DIST，顶点索引就根据纹理不同将统一创建这9*9个索引在一起。
先根据纹理，再设置索引，一次性渲染同一张纹理的所有格子。

17:31 2008-8-9
KOK地形模块渲染：
分两块实现：1、数据块。2、渲染块。
分别用Terrain和TerrainInstance做相应的功能。
Terrain负责数据加载，解析，保存数据和所有district。
TerrainInstance负责渲染，更新meshpool，填充顶点等。

设定：渲染主角所在范围3*3大小的DISTRICT，TerrainInstance中创建3*3个DistrictNodeInstance，主角移动时，实时更新这3*3个DistrictNodeInstance，而数据缓冲加载4*4个DISTRICT，但是，在主角移出范围时并不释放DISTRICT数据，而是一直保存着，直到切换地图，因为地图是限制的32*32个DISTRICT，所以不需要实时释放，这样当主角移回来的时候不需要再加载数据，可以提高效率。



15:13 2008-8-8
加载的DISTRICT可以不释放，反正最多32*32个DISTRICT，如果不释放，以后用的时候就不用再创建。

可能需要重新设计，需要考虑使用ModelInstance和ModelNodeInstance。

13:07 2008-8-7
1、加载地型块的方式
2、纹理渲染方式

原加载方式：
将所有地图数据一次性加载进来，如创建256*256个格子，把格子相关的阻挡、4层贴图、4个顶点、水面等级等等一次性创建，直接在内存中占用16M左右数据。

按dirstrict加载和处理数据，不需要cTerrainMeshGridNode这样庞大，把它的功能分解到每个dirstrict中。每个district保存9*9个node(即8*8个格子需要的顶点高度），这样每个dirstrict会浪费1*1数据，因为每个dirstrict都会有重复。

8*8

18:46 2008-8-6
纹理整合在一起渲染，只需要一个UV坐标（如果用SHADER，一个都不用，直接放到位置后面^^）
在进入DISTRICT前把用到的所有纹理都混合成一张纹理即可。

原万王渲染的缺陷：
贴图是按格子来的，也就是说一个格子最多可以放四张贴图，而渲染是以DISTRICT为单位，一个DISTRICT最多可以使16张贴图，这样就导致每次渲染贴
图数都不一样，目前是通过设置顶点索引的办法解决的（不太好）：根据纹理层次、贴图、格子组织顶点索引，也就是说将四层中所有贴图相同的索引在一起，这样一来，如果贴图没超过四张，就可以一次渲染完成，否则就要多做一次渲染。在一次渲染过程中，如果一个格子用到了多张贴图，会画多次。


0:02 2008-8-6
vb怎么组织？按district组织，一个district = 8*8*16*4
dynamic vb

15:35 2008-8-5
问题：顶点带宽太大，使用了五个纹理坐标来表示每层和阴影纹理的位置！
解决：
1、因为每张纹理中的块大小是固定的，所以使用shader，传入块编号，来使用纹理，这样四张纹理要传入4个编号，再加一个阴影，就是5个float
2、因为大部份地型上不需要做混合，只用一张纹理，只有处理边界的时候才需要混合，所以在进入场景的时候预渲染一张纹理，把所有用到的边界先渲上去，用的时候碰到使用混合的就从这里取纹理，这样就可以用一张纹理，一张阴影图搞定。

看样子只能选择第1种。

0:05 2008-8-5
已实现lpq支持

解析并渲染地型：
1、设置地型顶点
2、纹理
3、组织方式，目前看来如下：
总大小 256*256
被分成32*32个district
每个district有8*8个格子
每个格子大小为5，如果放大就是10

渲染以district为单位，地型VB是动态的（m_pTileVB)
所有的地型数据都在cTerrain中组织，其中包含32*32个cDistrict，每个district包含8*8个格子和cDistRender、cCliffRender等，用于具体的渲染。
创建一个district顶点的数量好像是256*32，不知道为什么？


22:34 2008-8-2
已实现用FMemStack，因为功能比FrameAllocator更强。
主要用于临时变量的处理。使用都是通过new来实现!!

理想的安排，根据具体情况会有所变动，前面一星期的内容必需安时尽快完成，后面的东西可以分部份给别人做（如应用层）

下一步安排：		天数
支持解析WE文件		1
解析地形并渲染		5
解析模型并渲染		3
解析人物动画并渲染	5
场景管理		3	8.25号

调整并优化		1	在场景中帧数保持在50以上

人物			2-3	骨骼绑定、动作混合
speedtree		2-3	需要添加个支持库，并优化
灯光、雾		1
天空			1
水			2-3	折射、反射、HeatHaze特效
粒子			2
特效			2	实现简单特效或者框架
声音			1
脚本			2	不确定，可能需要新的数据库支持
GUI			2	功能的东西需要做些调整，所以大部份时间花在怎么兼容功能上。
网络			1


应用层:
人物			1
NPC			1
寻路			1
...


0:26 2008-8-2
unreal的FMemStack功能与Torque的FrameAllocator相同，都是在一帧渲染过程中集中释放一些小内存块。
什么情况下使用这个？哪些变量使用它？每帧渲染的时候都需要new的变量？首先要搞清楚到低该怎么用!!!!

FMemStack和FrameAllocator的区别
1、前者在某个类中声明（也可在是全局的），退出类的时候释放
   后者声明为全局，退出的时候设置标志，并不真正清除


0:43 2008-7-28
今天出现两个引擎设计问题：
1、多线程资源加载和解析，目前引擎并不提供多线程解析，用的消息机制并不支持继承，所以需要再创建一个线程专门做解析，并且跟据不同类型数据重载解析函数。
2、加载数据的类(XXXloader)是调用不同类型数据类设置各种数据，因为变量是保护的，所以要设置很多函数，非常繁锁，解决办法：直接设置加载类(XXXloader)为友员类，然后加载的时候直接调用变量设置。
	这样一来就不需要像老方法那样，每个资源类都需要继承自AsyncLoad把加载和解析放在资源类里面处理。

2:36 2008-7-25
内存管理，unreal3上有个FMallocWindows分配内存以及FStackMask用于临时变量分配，与TORQUE里面的DataChunk和FramerAllocator相似，看看哪个效率高，拿来使用。
另外，还要再加一个Memory pool固定大小内存的管理。

unreal3里面的Array、map可以拿过来用，效率应该不错，当然要与stl比较一下。

11:39 2008-7-21
让CPU在空闲的时候加载周边CHUNK，要显示的CHUNK优先加载。


22:38 2008-7-15
昨天的设想不用，直接把整个ADT文件流保存在TerrainTile中，每个chunk初化的时候只保存相对流中数据位置的指针（初始化时读取位置和BOX然后保存CHUNK偏移指针，别的什么都不干!!），当地图块可见的时候读取相应的数据。释放tile的时候删除占用的空间。

这样读文件的时候好像是快了，但是用数据的时候还要解析，而且在主线程，还不如用昨天的方法，将解析完的数据存起来，用的时候直接拿出来就可以。

23:01 2008-7-14
在TerrainTile中保存一份Stream，这份Stream中保存着所有chunk使用到的数据（如alpha、shadow贴图的源数据），这些数据从线程中取得，并不直接在主线程中创建相应的纹理，等到可见的时候再创建。
所有地型纹理也是在可见的时候才加载！！

22:50 2008-6-22
工作流程：
M2->N2
简单的场景，不需要数据库
简单物理效果（BOX碰撞），模拟功击和受到功击
粒子效果
拿武器

1:52 2008-6-19
效率！简单！
目标：实现多人在线对战休闲游戏。操作方式、视角与魔兽争霸相同！即45度固定视角。
疑惑1：采用WOW的M2模型格式，重新在N3里面实现一套支持M2的应用层设计，或者把M2格式转成N2格式。

采用前一种方式的好处：
根据原来的分析，M2格式设计上比N2要好，存储空间少，在内存中占用也会少些。

缺点：
重新设计一套应用层，与目前的一套结合。
实现骨骼动画、混合、绑定点等。

采用后一种方式的好处：
与应用层完美结合，只要把M2格式转过来后，可以继续实现粒子系统等。
基本功能已全部实现。

从开发效率和追求简单来说，无疑会选择后者，前者要做很多事，当然也可以学到很多东西，不过以目标为前提的情况下，
还是选择后者吧！！！


1:42 2008-6-13
继承BaseGameFeatureUnit，重载NewGame函数，建立自己的场景，目前不需要数据库。

1、简单的加载一张ground模型做为场景即可。
2、显示M2模型，并能做简单的动画
3、键盘操作，做动作，在场景中移动
4、实现动画多轨混合（M2里面应该可以实现双轨）
5、粒子效果绑定
6、碰撞
7、简单打斗物理效果。

第7点开始需要在场景中放两个对象（可以是BOX）。

希望可以在7月份之间完成4步！


1:40 2008-6-12
整个地形设计有问题，在entity中不能创建其它entity，就算创建了，删除的时候也不能在entity中删除，否则会出问题。
重新设计TerrainEntity，不用继承自GraphicsEntity，直接放到WorldManager管理即可！暂时不解决，接下来的项目可能不用地形。

接下来开始做Fighter 3D项目！

1:26 2008-6-11
这边的工作先放一下，目前不适合做大型RPG游戏开发，先做个休闲格斗游戏，从今天开始，做Fighter 3D游戏。

工作安排如下：
修改目前NEBULA中出现的问题（如释放出错等）
熟悉并搭建NEBULA3应用层，开始做游戏。
加载一张ground模型做为地形，休闲游戏场景不会太大，所以只用一个模块搞定。
实现角色动画，格斗效果。
实现粒子和魔法效果。


0:03 2008-6-10
昨天将ResourceManager、SimplerResourceMapper、ShareResourceManager三块用stl::hashmap代替了原来的Directory。
加载模块已经达到常量级，已基本实现不卡。

接下来的工作：
1、地形正常浏览，目前地形加载模块设计不理想，加载模块可以尝试用原来的方法（而不是使用发消息去加载，待定！）。
2、四叉树，场景更新和渲染目前只有十几帧。
3、天空
4、水
5、模型：静态、动态
6、八叉树
7、WMO
8、粒子
9、特效：广告牌、HDR、BLOOM、等等
10、地形编辑器
11、模型编辑器
...

2:57 2008-5-30
把ResourceManager和SimaplerResourceMapper整合在一起了，用同一个资源HashTable，这样创建和查找的时候就只有一份数据，避免浪费。
速度有所提升，今天没怎么测试到低ResourceManager哪块卡。

hasttable类中还有个BUG，没时间了，下次解决。
目标是DEBUG版只加载地形要达到100帧以上，加载还要流畅！！！

2:20 2008-5-29
资源管理中替换成HashTable，效率有所提升，不过数量多的时候还是非常卡。
尝试用std::map

测试具体在哪个位置卡。(可以肯定是在CreateManagedResource里面某处)

2:24 2008-5-28
尝试将资源管理中用的Directory改成HashTable.以提高效率。
发现用Atom<String>做为ResourceId非常慢，因为每次资源增加的时候都需要排序，对字符串进行strcmp，这个函数非常慢，特别是调用次数过多的时候。
2:23 2008-5-26
两处可能引起卡的问题：
1、在Stage中更新所有entity，一旦enttiy很多的情况下，每个entity都要创建instance，会很慢，
	解决办法：把动态和静态entity分开，更新的时候只更新动态的。在加载的时候创建instance，必免更新的时候在一起创建，从而占用大量时间。
2、在资源管理模块中所有的资源都在一起更新，比如在ShaderResource中的resource是Directory类，每次增加一个资源都会排个序，非常慢。
	未解决，有待测试。


2:27 2008-5-22
新的加载方式导致WDT未加载成功
CHUNK加载的时候非常快，卡住可能是主线程哪里加载的时候有问题。

1:59 2008-5-19
随着加载数量的增加，明显的越来越慢，加载完成后虽然帧数很低，但相对稳定，所以第1点应该是问题的关键：
1、四叉树查找的时候会不会慢，将对象添加到合适的位置费多少时间？
2、查看渲染了多少对象，随着渲染对象的增加，也会降低速度。
3、视锥裁剪改成furstum

另外，将MPQ加载方式改成用stromLib！
实现连续加载地形。

2:42 2008-5-15
cell分布有问题，四叉树中的实例不是平均分布的？

1:49 2008-5-12
多线程加载基本框架已实现，还存在些问题，如怎么样设置managed里面的变量！！
多线程加载方式：辅助线程加载文件，需要数据的地方发读文件消息从辅助线程读，而不是一定性全加载了。

正常运行并显示地形
测试速度
添加FPS

=========================================================================================
lod
camera
fps

adtread的时候new新的内存，这块需要改掉。目前主线程还是很卡。terrainchunkentity放到WorldManager中实现。




M2
换装
max插件


需要处理的东西：

地形
  模型变换（位置、旋转、缩放）
  所有资源的BOUNDBOX（变换后BOX也要跟着变换）
  地图上有些小点空隙

  静态阴影(lightmap)
  加载多块地形（根据摄像机移动来加载需要的地块，释放不需要的地块）
  地形四叉树管理
    quadtree

  灯光
  地形高光

  Lod

wmo 
  protal bsp

m2 
  动画 粒子系统 mipmap

其它
  water
  sky
  fog
  load system  
    cpu->memory  memory->gpu
  index buffer 使用TRIANGLE STRIP，最后一个三角形使用退化（degenerate triangle）处理。



计划: bsp portal loadsystem animation partical water sky fog 优化  WorldEditor ModelEditor ParticalEditor
时间: 2008-2-22                                          2008-3-30                                      2008-5-30
////////////////////////////////////////////////////////////////////////////////////////////////////

floating-point precision errors 浮点精度问题
http://www.cs.unc.edu/~geom/theses/gottschalk/main.pdf     aabb


0.使用天空球包围整个世界,使用雾限制可控远景.
1.地形裁减: 
  1.使用四叉树算法对MapArea->AreaChunk逐层进行相对镜头的可见性裁减.
  2.在1过程中,对镜头内的地形进行水平线扫描剔除.
  2.然后镜头裁减完的区域必然是连续区域,对此连续区域作ROAM算法下的LOD处理,近细远粗.
2.模型裁减: 
  1.基于上述地形四叉树裁减下作基本的每一个模型的裁减,实践测试结果表明收益大于测试成本.
  2.距离裁减:以镜头为中心画圆,处于远景雾外的模型不作渲染,模型进雾后会逐步显示,这样不会有poping缺陷.
  3.不采用模型LOD,数据制作过于复杂,控制复杂,加大内存需求,也有poping缺陷,优点不明显.
  4.在地形水平线裁减中剔除物体.
3.进入BSP室内场景后的裁减.
