资源	加载	渲染	场景管理	多线程	
================

SharedResourceServer  资源共享




WM4
VisibleObject  渲染前设置可见对象


vertexbuffer功能：
顶点格式FVF  VertexLayout	VertexDecl -- VertexLayout
顶点大小
复制顶点数据 Lock unlock
设备管理 IDirect3DVertexBuffer9



WM4
vertexbuffer:
顶点属性（Position、Normal、Color、Fog、BlendIndices、Coord...)
顶点数据
设备管理（在bindable中保存设备指针)


effect begin
commit
effect end

D3D9RenderDevice::BeginFrame
    FrameShader::Render					控制渲染多个FramePass
        FramePass::Render				渲染到rendertarget
	    // apply shader variables

	    D3D9RenderDevice::BeginPass
	    FrameBatch::Render				批次渲染，几个特效组合需要多次渲染。
		// apply shader variables

		BeginBatch
		RenderBatch				设置Technique,variable等，并循环渲染
		  GetVisibleModels			获取可见对象
		  GetVisibleModelNodes			为每个Model获取Nodes
		  SetFeatureBits			设置technique
		  ApplySharedState			应用着色变量的状态
		  SelectActiveVariation			激活technique

		  GetVisibleModelNodeInstances		获得可见对象的所有实例，循环渲染所有实例
		  ApplyState				应用实例的着色变量
		  Render				渲染实例

		EndBatch
	    D3D9RenderDevice::EndPass
D3D9RenderDevice::EndFrame




WM4渲染过程

Polylines::OnIdle
  Renderer::DrawScene		获得可见对象
    Renderer::Draw		渲染
      SetGlobalState		设置全局状态（固定管线）
      EnableIBuffer		设置索引缓冲
      循环应用所有的效果（如果有多个）
      ApplyEffect		应用效果并渲染
        SetGlobalState		为每个EffectShader设置渲染状态（固定管线）
	EnableVProgram		顶点着色
	EnablePProgram		像素着色
	EnableTexture		设置纹理
	EnableVBuffer		顶点缓冲(这里还要从Attributes获取FVF）
	DrawElements		真正渲染
	...





资源建立方式,具体见N3的ResourceManager
ResourceManager
    SharedResourceServer
        Resource

ResourceManager::CreateResource(const Rtti& resType, const string resName)
ResourceManager::CreateResource(const Rtti& resType, const ResourceId& resId)
{
    SharedResourceServer::CreateSharedResource(resId, resClass, resLoaderClass)
    load resource
}

vertex layout（FVF）设置方法:
Array<VertexComponent> vertexComponents;
vertexComponents.Append(VertexComponent(VertexComponent::Position, 0, VertexComponent::Float3));
vertexComponents.Append(VertexComponent(VertexComponent::TexCoord, 0, VertexComponent::Float2));
VertexBuffer.Setup(vertexComponents);


shader应用:

shader
    constants
    program

EnableVProgram
    SetVertexShader()
    process the sampler information		设置纹理采样信息，指定采样类型、纹理编号
    process the render constants		获取全局着色变量值，并设置到指定寄存器
    process the numerical constants
    process the user-defined constants
EnablePProgram
    步聚同上
EnableTexture V
    Anisotropic filtering value
	D3DSAMP_MAXANISOTROPY
    Set the filter mode
	D3DSAMP_MAGFILTER
    Set the mipmap mode
	D3DSAMP_MINFILTER
	D3DSAMP_MIPFILTER
    Set the border color (for clamp to border)
	D3DSAMP_BORDERCOLOR
    Set Address mode
	D3DSAMP_ADDRESSU
	D3DSAMP_ADDRESSV
	D3DSAMP_ADDRESSW   如果是3d采样
    SetTexture
EnableTexture P
    同上
OnEnableVBuffer
    SetStreamSource
    SetVertexDeclaration
Draw


Spatial
    Local		本地坐标
    World		世界坐标
    WorldBound		世界包围盒
    CullingMode		栋选方式
    m_pkParent		父指针
    m_kGlobalStates	全局渲染状态（数组）
    m_kLights		灯光状态（数组）
    m_kEffects		特效状态（数组）  多次着色过程

Geometry 继承自Spatial
    VertexBufferPtr	顶点缓冲
    IndexBufferPtr	索引缓冲
    BoundingVolumePtr	模型包围盒
    LightingEffectPtr	光照效果
    GeometryType     	PrimitiveTopology  渲染方式(LineList、TriangleStrip等)
    GlobalState    	全局渲染状态(alpha,cull,material,zbuffer等等)
    
特殊的对象可以继承Geometry来实现特殊化。

Node 继承自Spatial
    m_kChild



GeometryInstance
    PrimitiveGroup			记录渲染顶点的开始位置和数量等信息。
    Geometry				具体数据
    BoundingVolumePtr			子模型包围盒
    vector<ShaderVariableInstance>	shader variable  instance 多个变量
    vector<ShaderInstance>		effect 多个shader


    
渲染状态设置方式：在引擎中不设置任何全局状态(WM4中有)，如果需要设置，在technique中设置，然后在ShaderInstance中选择不同的technique(通过ShaderFeature::Mask)，渲染前应用ShaderInstance，并将所有变量应用。 每个对象可以选择不同的technique,这样当使用不同的渲染状态时，可以建立多个technique。




Renderer::DrawScene
    循环处理所有可见对象
    Draw(Geometry*)
        SetGlobalState
        SetWorldTransformation		从Draw参数传进一个Geometry，在这里更新世界矩阵，着色所需
	EnableIBuffer			用Geometry设置索引缓冲
	获得效果文件(数组)		Start,Quantity,效果文件从Start位置开始取Quantity个数量渲染
	


使用bsp：
WM中BSP将空间分割成正、负和分割线三部份。
怎么判断视截体在正面还是负面？Plane类有个成员函数WhichSide，判断输入的点是正边还是负边，Camera类
有个成员函数WhichSide用于测试视截体的八个点在哪面，如果八个点都在正面，则返回正，如果八个点都在负
面，则返回负面，如果有些在正面有些在负面，就返回0.


The root of the BSP tree is a
special node that helps determine in which leaf region the eye point is.

BSP树的根节点是一个特殊的节点，它用于决定当前眼睛在哪个叶子范围。


wm4渲染时，如果有多个对象使用相同的EFFECT，将排好序，调用相应EFFECT的DRAW函数渲染，如在NODE设置一个EFFECT，将影响其下的所有子节点。




渲染状态管理：
以下几个地方比较耗时，
1、Vertex/Fragment Program模式和固定管线模式的切换（FF，Fixed Function Pipeline） 
2、Vertex/Fragment Program本身程序的切换 
3、改变Vertex/Fragment Program常量 
4、纹理切换 
5、顶点和索引缓存（Vertex & Index Buffers）切换 

渲染状态分类：
实际场景中，往往会出现这样的情况，一类对象其它渲染状态都一样，只是纹理和顶点、索引数据不同。
所以按以下步骤渲染：
1、将相同的渲染状态分成一组。
2、将1中分好的组按纹理不同排序，相同纹理的一起渲染。

多道渲染（Multipass Rendering）
一些老的显卡或较复杂的效果需要多次渲染才能实现，渲染一次就是一个pass，如SHADOWMAP。
不同的pass往往渲染状态和纹理都不同，而顶点、索引数据是一样的。
这带来一个问题：是以对象为单位渲染，一次渲染一个对象的所有pass，然后渲染下一个对象；还是以pass为单位渲染，第一次渲染所有对象的第一个pass，第二次渲染所有对象的第二个pass。
　　以对象为单位渲染，渲染一个对象的第一个pass后，马上紧接着渲染这个对象的第二个pass，而每个pass的顶点和索引数据是相同的，因此第一个pass将顶点和索引数据送入显卡后，显卡Cache中已经有了这个对象顶点和索引数据，后续pass不必重新将顶点和索引数据拷到显卡，因此速度会非常快。而问题是每个pass的渲染状态都不同，这使得实际上每次渲染都要设置新的渲染状态，会产生大量的多余渲染状态切换。

　　以pass为单位渲染则正好相反，以Shader分组，相同Shader的对象一起渲染，可以只在这组开始时设置一次渲染状态，相比以对象为单位，大大减少了渲染状态切换。可是每次渲染的对象不同，因此每次都要将对象的顶点和索引数据拷贝到显卡，会消耗不少时间。


我们选择以pass为单位渲染。



N3的渲染状态全部使用FX文件实现，每个对象的EFFECT在.n2脚本文件中指定包括变量，总的渲染过程在.xml文件中定义，也就是将渲染按PASS分类，具体每个PASS下面使用每个对象的EFFECT。
WM4渲染状态与Scene Graph结合，在SPATIAL中保存有对象EFFECT，如要实现特殊的效果需要建立一个类，在其中实现某种效果。

结合以上两个引擎，渲染部份实现如下：
渲染状态全部放到FX，代码中不需要设置任何GLOBAL STATE，为每个对象保存一个具体的实现EFFECT(ShaderInstance)。
WM4的
Render
Scene Graph
Effect		用于实现特殊效果，派生子类实现。在子类中使用ShaderInstance
VisiableSet	可见性判断



N3:ShaderInstance = WM4:ShaderEffect


可见对象对多次渲染的判断。visiableSet





